using SecondBrain.Application.Services.Voice.Models;

namespace SecondBrain.Application.Services.Voice;

/// <summary>
/// Service for Text-to-Speech (TTS) synthesis
/// </summary>
public interface IVoiceSynthesisService
{
    /// <summary>
    /// Provider identifier (e.g., "ElevenLabs", "Google", "OpenAI", "Azure")
    /// </summary>
    string ProviderName { get; }

    /// <summary>
    /// Whether the synthesis service is available and configured
    /// </summary>
    bool IsAvailable { get; }

    /// <summary>
    /// Stream synthesized audio chunks for the given text
    /// </summary>
    /// <param name="text">Text to synthesize</param>
    /// <param name="options">Synthesis options</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Async enumerable of audio chunks (base64 encoded)</returns>
    IAsyncEnumerable<byte[]> StreamSynthesisAsync(
        string text,
        SynthesisOptions options,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Create a streaming synthesis session for real-time text input
    /// This allows sending text incrementally as it's generated by the LLM
    /// </summary>
    /// <param name="options">Synthesis options</param>
    /// <param name="onAudio">Callback for audio chunks</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>A synthesis session that can receive text chunks</returns>
    Task<ISynthesisSession> CreateSessionAsync(
        SynthesisOptions options,
        Action<byte[]> onAudio,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Synthesize complete text to audio (non-streaming)
    /// </summary>
    /// <param name="text">Text to synthesize</param>
    /// <param name="options">Synthesis options</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Complete audio data</returns>
    Task<byte[]> SynthesizeAsync(
        string text,
        SynthesisOptions options,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Get list of available voices
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>List of available voices</returns>
    Task<IReadOnlyList<VoiceInfo>> GetAvailableVoicesAsync(
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Get information about a specific voice
    /// </summary>
    /// <param name="voiceId">Voice ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Voice information or null if not found</returns>
    Task<VoiceInfo?> GetVoiceAsync(
        string voiceId,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Check if the service is healthy and can accept requests
    /// </summary>
    Task<(bool IsHealthy, string? Error)> CheckHealthAsync(
        CancellationToken cancellationToken = default);
}

/// <summary>
/// A real-time synthesis session that can receive text chunks
/// This is optimized for streaming LLM output to TTS
/// </summary>
public interface ISynthesisSession : IAsyncDisposable
{
    /// <summary>
    /// Session identifier
    /// </summary>
    string SessionId { get; }

    /// <summary>
    /// Whether the session is connected and active
    /// </summary>
    bool IsConnected { get; }

    /// <summary>
    /// Send a text chunk for synthesis
    /// </summary>
    /// <param name="text">Text chunk to synthesize</param>
    /// <param name="cancellationToken">Cancellation token</param>
    Task SendTextAsync(string text, CancellationToken cancellationToken = default);

    /// <summary>
    /// Send a text chunk for synthesis with control over generation triggering
    /// </summary>
    /// <param name="text">Text chunk to synthesize</param>
    /// <param name="tryTriggerGeneration">Whether to attempt immediate audio generation</param>
    /// <param name="cancellationToken">Cancellation token</param>
    Task SendTextAsync(string text, bool tryTriggerGeneration, CancellationToken cancellationToken = default);

    /// <summary>
    /// Send text and immediately flush to generate audio, without closing the stream.
    /// Use this for announcements that need to be spoken immediately while allowing
    /// more text to be sent afterward.
    /// </summary>
    /// <param name="text">Text to synthesize immediately</param>
    /// <param name="cancellationToken">Cancellation token</param>
    Task SendTextAndFlushAsync(string text, CancellationToken cancellationToken = default);

    /// <summary>
    /// Signal end of text stream and flush remaining audio.
    /// This sends an EOS (end-of-sequence) signal and closes the generation stream.
    /// No more text can be sent after this.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    Task FlushAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Flush current text to generate audio immediately without closing the stream.
    /// Use this for announcements where you want to speak immediately but continue
    /// sending more text afterward (like the main response).
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    Task FlushWithoutClosingAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Reinitialize the session for a new generation after a flush.
    /// Call this after FlushAsync if you want to send more text.
    /// Note: After EOS, this may not work with all TTS providers.
    /// Prefer FlushWithoutClosingAsync for mid-stream flushes.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    Task ReinitializeAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Cancel any pending synthesis (used for interruption)
    /// </summary>
    Task CancelAsync();

    /// <summary>
    /// Close the synthesis session
    /// </summary>
    Task CloseAsync();
}
