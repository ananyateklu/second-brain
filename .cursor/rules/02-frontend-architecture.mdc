---
description: Guidelines and patterns for the React frontend architecture
globs: frontend/**/*.ts, frontend/**/*.tsx, src/**/*.ts, src/**/*.tsx
alwaysApply: false
---
# Frontend Architecture

The Second Brain frontend is built with React 18, TypeScript, Vite, and TailwindCSS. It follows a context-based state management approach with optimized provider organization for different concerns.

## Directory Structure

```
frontend/
├── src/
│   ├── assets/               # Static assets (images, icons)
│   ├── components/           # React components
│   │   ├── Dashboard/        # Dashboard-related components
│   │   ├── shared/           # Shared/reusable components
│   │   ├── ErrorBoundary.tsx # Global error boundary component
│   │   └── ProtectedRoute.tsx # Auth protection component
│   ├── contexts/             # React Context providers
│   │   ├── *Context.tsx      # Context provider components
│   │   └── *contextUtils.ts  # Utils for respective contexts
│   ├── hooks/                # Custom React hooks
│   ├── routes/               # Route definitions and components
│   ├── services/             # Service layer for external interactions
│   │   ├── api/              # API client services
│   │   │   ├── api.ts        # Base API client with interceptors
│   │   │   └── *.service.ts  # Domain-specific API services
│   │   ├── ai/               # AI provider implementations
│   │   │   ├── models.ts     # AI model definitions
│   │   │   ├── openai.ts     # OpenAI implementation
│   │   │   ├── anthropic.ts  # Anthropic/Claude implementation
│   │   │   ├── gemini.ts     # Google Gemini implementation
│   │   │   ├── grok.ts       # Grok implementation
│   │   │   ├── llama.ts      # Local LLM implementation
│   │   │   └── messageService.ts # Message handling service
│   │   └── notification/     # Notification services
│   ├── theme/                # Theme configuration
│   │   ├── theme.config.ts   # Theme definitions
│   │   └── themeConfig.types.ts # Theme type definitions
│   ├── types/                # TypeScript type definitions
│   ├── utils/                # Utility functions
│   │   ├── dashboard/        # Dashboard-specific utilities
│   │   ├── themeScript.ts    # Early-load theme script
│   │   └── *.utils.ts        # Domain-specific utilities
│   ├── App.tsx               # Main App component
│   ├── index.css             # Global CSS
│   └── main.tsx              # Application entry point
```

## Optimized Context Providers

The application uses a streamlined context provider architecture in `App.tsx`:

```tsx
// Centralized context provider component to improve organization and performance
const AppProviders = ({ children }: { children: React.ReactNode }) => (
  <ErrorBoundary onError={logError}>
    <ThemeProvider>
      <BrowserRouter future={{
        v7_startTransition: true,
        v7_relativeSplatPath: true
      }}>
        <AuthProvider>
          {children}
        </AuthProvider>
      </BrowserRouter>
    </ThemeProvider>
  </ErrorBoundary>
);

// Feature-specific providers that are only loaded when needed
const FeatureProviders = ({ children }: { children: React.ReactNode }) => (
  <ErrorBoundary onError={logError}>
    <AIProvider>
      <RecordingProvider>
        <ActivityProvider>
          <ModalProvider>
            <TrashProvider>
              <RemindersProvider>
                <NotesWithRemindersProvider>
                  <TasksProvider>
                    <DashboardProvider>
                      {children}
                    </DashboardProvider>
                  </TasksProvider>
                </NotesWithRemindersProvider>
              </RemindersProvider>
            </TrashProvider>
          </ModalProvider>
        </ActivityProvider>
      </RecordingProvider>
    </AIProvider>
  </ErrorBoundary>
);
```

This improved organization loads app-wide providers first and feature-specific providers only when needed.

## Key Context Providers

- **AuthContext**: Authentication state and operations
- **ThemeContext**: Theme settings and operations
- **NotesContext**: Notes data and operations
- **TasksContext**: Tasks data and operations
- **RemindersContext**: Reminders data and operations
- **AIContext**: AI provider configurations and operations
- **DashboardContext**: Dashboard UI state and settings
- **TrashContext**: Deleted items management
- **ModalContext**: Modal dialog management
- **ActivityContext**: User activity tracking
- **RecordingContext**: Audio recording for transcription

## Component Patterns

1. **Feature-based organization**: Components are organized by feature (Notes, Tasks, etc.)
2. **Compound components**: Complex UI elements use compound component pattern
3. **Custom hooks**: Business logic is extracted into custom hooks
4. **Context consumers**: Components use context via custom hooks (`useNotes`, `useTasks`, etc.)
5. **Error boundaries**: Components are wrapped with error boundaries for resilience
6. **Lazy loading**: Route components are lazy-loaded for optimized performance

## API Integration

The API client in `services/api/api.ts` implements token management and request/response interceptors:

```typescript
// Token management interface
interface ITokenManager {
  getAccessToken(): string | null;
  getRefreshToken(): string | null;
  setTokens(accessToken: string, refreshToken: string): void;
  clearTokens(): void;
}

// API instance with interceptors
const api = axios.create({
  baseURL: 'http://localhost:5127',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor adds auth token
api.interceptors.request.use(config => {
  const token = TokenManager.getAccessToken();
  if (token) {
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor handles token refresh
api.interceptors.response.use(
  response => response,
  async error => {
    // Handle 401 with token refresh logic
    if (error.response?.status === 401 && !originalRequest._retry) {
      // Token refresh logic with race condition prevention
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          pendingRequests.push({
            resolve,
            reject,
            config: originalRequest
          });
        });
      }
      
      isRefreshing = true;
      // Refresh token implementation
      // ...
    }
    return Promise.reject(error);
  }
);
```

Domain-specific services build on this API client:

```typescript
// Example notes service
export const notesService = {
  getNotes: async (): Promise<Note[]> => {
    const response = await api.get('/api/notes');
    return response.data;
  },
  
  createNote: async (note: CreateNoteDto): Promise<Note> => {
    const response = await api.post('/api/notes', note);
    return response.data;
  }
};
```

## Authentication System

The authentication system uses a hybrid approach for secure token storage:

```typescript
// TokenManager in AuthContext.tsx
export class TokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'access_token';
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token';

  // In-memory storage for access token to avoid XSS attacks
  private static accessToken: string | null = null;

  static getAccessToken(): string | null {
    return this.accessToken;
  }

  static getRefreshToken(): string | null {
    return localStorage.getItem(this.REFRESH_TOKEN_KEY);
  }

  static setTokens(accessToken: string, refreshToken: string) {
    this.accessToken = accessToken;
    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);
  }
  
  static clearTokens() {
    this.accessToken = null;
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);
  }
}
```

This approach stores access tokens in memory for security while keeping refresh tokens in localStorage for persistence.

## SignalR Integration

The application uses SignalR for real-time communication with built-in reconnection handling:

```typescript
// SignalR connection with auth token
const connection = new signalR.HubConnectionBuilder()
  .withUrl(`${baseUrl}/toolHub`, {
    accessTokenFactory: () => TokenManager.getAccessToken() || '',
  })
  .withAutomaticReconnect({
    nextRetryDelayInMilliseconds: (retryContext) => {
      // Exponential backoff logic
      const delay = Math.min(
        1000 * Math.pow(2, retryContext.previousRetryCount),
        30000 // Max 30 seconds
      );
      return delay;
    }
  })
  .build();
```

## Multi-Provider AI System

The application integrates with multiple AI providers through a unified interface:

```typescript
// AI Model definitions
export interface AIModel {
  id: string;
  name: string;
  provider: AIProvider;
  capabilities: ModelCapability[];
  contextWindow: number;
  maxOutputTokens: number;
  category: ModelCategory;
  isStreaming: boolean;
}

// Provider-specific implementations
// OpenAI implementation
export const sendMessageToOpenAI = async (
  message: string,
  modelId: string,
  messageCallback: (message: string) => void
): Promise<void> => {
  // OpenAI-specific implementation
};

// Anthropic/Claude implementation
export const sendMessageToAnthropic = async (
  message: string,
  modelId: string,
  messageCallback: (message: string) => void
): Promise<void> => {
  // Anthropic-specific implementation
};

// Message handling service
export const sendMessage = async (
  message: string,
  modelId: string,
  messageCallback: (message: string) => void
): Promise<void> => {
  const model = getModelById(modelId);
  
  switch (model.provider) {
    case 'openai':
      return sendMessageToOpenAI(message, modelId, messageCallback);
    case 'anthropic':
      return sendMessageToAnthropic(message, modelId, messageCallback);
    case 'gemini':
      return sendMessageToGemini(message, modelId, messageCallback);
    case 'grok':
      return sendMessageToGrok(message, modelId, messageCallback);
    case 'llama':
      return sendMessageToLlama(message, modelId, messageCallback);
    default:
      throw new Error(`Unsupported provider: ${model.provider}`);
  }
};
```

## Theme System

The theme system uses a multi-layered approach with CSS variables, Tailwind classes, and early-load script:

### Theme Configuration

```typescript
// Theme configuration in theme.config.ts
export const themes: Record<ThemeName, ThemeConfig> = {
  light: {
    name: 'Light',
    colors: {
      primary: '#2563eb',
      secondary: '#64748b',
      background: '#ffffff',
      surface: '#f8fafc',
      text: '#1e293b',
      // Many more color definitions...
    }
  },
  dark: {
    // Dark theme colors...
  },
  midnight: {
    // Midnight theme colors...
  },
  'full-dark': {
    // Full dark theme colors...
  }
};
```

### Theme Application

```typescript
// Apply CSS variables
Object.entries(theme.colors).forEach(([key, value]) => {
  root.style.setProperty(`--${key}`, value);
  root.style.setProperty(`--color-${key}`, value);
});

// Apply Tailwind classes
root.classList.remove('light', 'dark', 'midnight', 'full-dark');
root.classList.add(themeName);

// Set color-scheme property
root.style.colorScheme = themeName === 'light' ? 'light' : 'dark';
```

### Early-Load Theme Script

The application uses a script to apply the theme before the React app loads to prevent flash of unstyled content:

```typescript
// themeScript.ts - Embedded in index.html
export const themeScript = `
  (function() {
    // Embed the themes configuration directly into the script
    const themes = ${themesJSON};
    
    try {
      const savedTheme = localStorage.getItem('theme');
      const systemDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      // Determine the initial theme
      let themeName = savedTheme;
      if (!themeName || !themes[themeName]) {
        themeName = systemDarkMode ? 'dark' : 'light';
      }

      // Apply theme to HTML root
      const root = document.documentElement;
      root.setAttribute('data-theme', themeName);
      root.classList.toggle('dark', themeName !== 'light');
      
      // Apply CSS variables
      const themeColors = themes[themeName].colors;
      for (const key in themeColors) {
        root.style.setProperty('--' + key, themeColors[key]);
        root.style.setProperty('--color-' + key, themeColors[key]);
      }
      
      // Safari-specific fixes
      // ...
    } catch (e) {
      console.error('Error applying initial theme:', e);
    }
  })();
`;
```

## Dashboard Visualization System

The dashboard uses a modular visualization system with:

1. **Stats Registry**: Central registry mapping stat IDs to handler functions
2. **Stat Handlers**: Specialized modules calculating specific statistics
3. **Visualization Components**: Reusable chart and visualization components
4. **Responsive Layouts**: Cards that adapt to different sizes and screen widths

```typescript
// Stats Registry Pattern
type StatHandler = (data: StatHandlerData) => StatValue;

const statsRegistry: Record<string, StatHandler> = {
  'total-notes': ({ notes }) => getTotalNotesStatValue(notes),
  'active-tasks': ({ tasks }) => getActiveTasksStatValue(tasks),
  // Other stat handlers...
};

// Dashboard Context provides stat configuration
export function useDashboardContext() {
  // State for enabled stats, sizes, and order
  const [enabledStats, setEnabledStats] = useState<string[]>(DEFAULT_ENABLED_STATS);
  const [statSizes, setStatSizes] = useState<Record<string, StatSize>>(DEFAULT_STAT_SIZES);
  const [statOrder, setStatOrder] = useState<string[]>(DEFAULT_STAT_ORDER);
  
  // Functions to manage stats
  const toggleStat = (statId: string) => { /*...*/ };
  const resizeStat = (statId: string, size: StatSize) => { /*...*/ };
  const reorderStats = (newOrder: string[]) => { /*...*/ };
  
  // ...
}
```

## Important Notes

1. **Error Handling**: All components should use error boundaries
2. **Provider Dependencies**: Some contexts depend on others being initialized first
3. **Safari-specific Code**: Theme system has special handling for Safari browser
4. **Optimistic Updates**: Many operations update local state before API calls complete
5. **Lazy Loading**: Use lazy loading for components to improve performance
6. **Token Security**: Access tokens stored in memory, refresh tokens in localStorage
7. **Multi-theme Support**: Four themes with CSS variables and Tailwind integration
8. **AI Provider Abstraction**: Unified interface for multiple AI providers 